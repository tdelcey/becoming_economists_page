---
title: "Exploring gender preferences in French Ph.D."
author: 
  - name: "Thomas Delcey"
    affiliation: "Université de Bourgogne"
    email: "Thomas.delcey@u-bourgogne.fr"
  - name: "Aurelien Goutsmedt"
    affiliation: "UC Louvain; ICHEC"
    email: "aurelien.goutsmedt@uclouvain.be"
categories:
  - French data 
format: 
  html: 
    page-layout: full
    toc: true
    toc_float: true
    date: "2024"
    date-format: "YYYY"
    code-fold: true 
    code-summary: "Show the code"
    warning: false
    message: false
    lightbox: true
bibliography: references.bib
editor_options: 
  chunk_output_type: console
---


```{r}
#| echo: FALSE 
#| warning: FALSE
#| message: FALSE

pacman::p_load(
  "here",
  "tidyverse",
  "tidytext",
  "stm",
  "tidystm",
  "glue",
  "DT",
  "spacyr",
  "ggiraph",
  "ggraph")

#### PATH ####

#original text path stored in google drive 
if(str_detect(getwd(), "tunex")){
  data_path <- "G:/Mon Drive/Phd_Project/data"
} else {
  if(str_detect(getwd(), "Admin")) {
    data_path <- "G:/.shortcut-targets-by-id/1Lhjzr0rDBjblTPYh9PoVBsi_uupV9z8L/Phd_Project/data"
  } else {
  if(str_detect(getwd(), "thomd")) {
    data_path <- "G:/.shortcut-targets-by-id/1Lhjzr0rDBjblTPYh9PoVBsi_uupV9z8L/Phd_Project/data"
    } else {
      data_path <- "G:/.shortcut-targets-by-id/1Lhjzr0rDBjblTPYh9PoVBsi_uupV9z8L/Phd_Project/data"
    }}
  }

#### PATH ####

#original text path stored in google drive 
if(str_detect(getwd(), "tunex")){
  data_path <- file.path(path.expand("~"), "google_drive/Mon Drive/Phd_Project/data")
} else {
  if(str_detect(getwd(), "Admin")) {
    data_path <- "G:/.shortcut-targets-by-id/1Lhjzr0rDBjblTPYh9PoVBsi_uupV9z8L/Phd_Project/data"
  } else {
    if(str_detect(getwd(), "thomd")) {
      data_path <- "G:/.shortcut-targets-by-id/1Lhjzr0rDBjblTPYh9PoVBsi_uupV9z8L/Phd_Project/data"
    } else {
      if(str_detect(getwd(), "agoutsmedt")) {
        data_path <- "/home/agoutsmedt/google_drive/Phd_Project/data"
      } else {
        data_path <- "G:/.shortcut-targets-by-id/1Lhjzr0rDBjblTPYh9PoVBsi_uupV9z8L/Phd_Project/data"
      }}}
}

FR_cleaned_data_path <- here(data_path, "cleaned_data/FR")
website_data_path <- here(data_path, "website_data", "stm_gender")

```

In this blog, we use the Structural Topic Model to analyze the effect of gender on Ph.D. students' choice of topics. The Structural Topic Model combines probabilistic topic modeling with regression analysis to examine the effect of document _metadata_ on the output of the topic model: topic content and topic prevalence. If you are not familiar with probabilistic topic models, we recommend reviewing the first [blog post](../../../../application/stm_title/) and the related references for background information before continuing.  

In the same [blog post](../../../../documentation/french/), we examined how topic prevalence was influenced by the `year of defence`. The intuitive idea was that the topics of a thesis crucially depend on the period in which it was written; what is considered a contribution evolves with the social context characterizing a given time period.  

However, we could obviously be more specific. When predicting topic prevalence using the `year of defense`, we acknowledge this "evolving social context" but do not specify what drives these changes. Yet, additional variables could help explain authors' topic choices. For instance, one of the most significant transformations in the French Ph.D. data is the increasing proportion of women pursuing a Ph.D. in economics. Are there topics that male Ph.D. students are more likely to examine, and conversely, topics that female Ph.D. students are more inclined to study? 

Let's explore this issue!  

# Explore the data

To run our topic model, we will use the french abstracts (`abstract_fr`) as the main textual input. As already showed [here](https://tdelcey.github.io/becoming_economists_page/application/stm_title#fig-textual_data), are a far better data than title to train a topic model but are only available from the early 1980s. But we will see that it is also at pretty much at the same period that the proportion of female authors increase dramatically. 

Let's explore the data to compute the distribution of gender in the french dataset. The individual table includes two distinct variables, `gender` and `gender_expanded`, which provide information about the gender of individuals (e.g., authors, supervisors): 

  - The `gender` variable contains raw information obtained from the [IdRef](https://www.idref.fr/) repository.
  - The `gender_expanded` variable is our enhanced version, which imputes missing gender values using French census data.  

A detailed explanation of these variables can be found in the [documentation](../../../../documentation/french/) of the French database available on this website. For this analysis, we will use the `gender_expanded` variable. 

The `gender_expanded` variable is derived from the individual table, whereas our textual data come from the metadata table. To link these variables, we must use the edge table, which associates each thesis identifier (`thesis_id`) with the corresponding entities (`entity_id`).  


```{r}
#| echo: TRUE
#| eval: TRUE
#| label: tbl-data
#| tbl-cap: Sample of metadata and individual tables 

thesis_metadata <- readRDS(here(FR_cleaned_data_path, "thesis_metadata.rds"))
thesis_individual <- readRDS(here(FR_cleaned_data_path, "thesis_individual.rds")) 

# Show sample of each tables for illustration 

# set seed 
set.seed(123)

# Sample data from thesis_metadata

metadata_sample <- thesis_metadata %>% 
  select(thesis_id, abstract_fr, year_defence) %>% 
  filter(!is.na(abstract_fr)) %>% 
  mutate(abstract_fr = str_trunc(abstract_fr, 10)) %>% 
  slice_sample(n = 5)

# Sample data from thesis_individual
individual_sample <- thesis_individual %>% 
  select(entity_id, entity_name, entity_firstname, gender_expanded) %>% 
  slice_sample(n = 5)



# Convert samples to datatables
metadata_table <- datatable(metadata_sample, options = list(pageLength = 5,
                                                            searching = FALSE,
                                                            lengthChange = FALSE), caption = " Metadata")
individual_table <- datatable(individual_sample, options = list(pageLength = 5,
                                                        searching = FALSE,
                                                        lengthChange = FALSE), caption = " Individuals")

# Display tables side by side using HTML
htmltools::browsable(
  htmltools::tagList(
    htmltools::tags$div(style = "display: flex; gap: 20px;",
      htmltools::tags$div(style = "flex: 1;", metadata_table),
      htmltools::tags$div(style = "flex: 1;", individual_table)
    )
  )
)


# Join them with edge table
thesis_edge <- readRDS(here(FR_cleaned_data_path, "thesis_edge.rds"))

authors_doc_id <- thesis_edge %>%
  filter(entity_role == "author") %>% 
  select(entity_id, thesis_id) %>% 
  unique

authors_gender <- thesis_individual %>% 
  select(entity_id, entity_name, entity_firstname, gender_expanded)

# manage duplicate
duplicates <- thesis_metadata %>%
   filter(!is.na(duplicates)) %>%
   group_by(duplicates) %>% 
   # when the line has a duplicate, group and keep the older value
   slice_max(year_defence, n = 1, with_ties = FALSE)

thesis_metadata_no_duplicate <- thesis_metadata %>% 
  filter(is.na(duplicates)) %>% 
  bind_rows(duplicates)

# We can now select the relevant variables for our stm
data <- thesis_metadata_no_duplicate %>% 
  # keep relevant columns
  select(thesis_id, abstract_fr, year_defence) %>% 
  # double join to add a gender to each document
  left_join(authors_doc_id, by = "thesis_id") %>%
  left_join(authors_gender, by = "entity_id")  

```

We can now evaluate the distribution of our data. @fig-gender_distribution illustrates the distribution of theses, categorized by gender.  

::: panel-tabset

### Distribution 

```{r}
#| echo: TRUE 
#| fig.cap: "Distribution of abstracts by gender"
#| label: fig-gender_distribution

data <- data %>%
  filter(!is.na(gender_expanded), !is.na(year_defence))

gg <- data  %>% 
  group_by(gender_expanded, year_defence) %>%
  summarise(n = n()) %>%
  ungroup %>%
  mutate(tooltip = paste("Année:", year_defence, "<br>Nombre d'auteurs:", n, "<br>Genre:", gender_expanded)) %>%
  ggplot(aes(
    x = as.integer(year_defence),
    y = n,
    fill = gender_expanded,
    text = tooltip
  )) +
  geom_col() +
  theme_light() +
  labs(x = "", y = "Nombre d'auteurs", fill = "Genre") +
  scale_fill_brewer(palette = "Set3") +
  theme_light()

plotly::ggplotly(gg, tooltip = "text") %>%
  plotly::config(displayModeBar = FALSE)

```

### Data 

```{r}
#| echo: TRUE 
#| warning: FALSE
#| label: tbl-gender_distribution
#| fig.cap: "Distribution du genre par année"

distribution <- data  %>% 
  group_by(gender_expanded, year_defence) %>%
  summarise(n = n()) %>%
  ungroup 

distribution %>% 
  DT::datatable(
  extensions = 'Buttons',
  options = list(
    dom = 'Blfrtip',
    buttons = c('excel', 'csv'),
    pageLength = 12
  )
)

```

::: 

The practice of including an abstract became common in the early 1980s, but few abstracts were available for theses defended in earlier decades. A closer examination shows, however, that these were added by librarians who created the entries. Therefore, it is reasonable to filter out theses defended before 1980.  

To run our probabilistic topic model, we follow the usual pre-processing steps, as described in this [post](../../../../application/stm_title/). The primary difference in this instance is the inclusion of a few custom stopwords to address highly redundant terms frequently found in abstracts, such as *chapter* (_chapitre_) or *thesis* (_thèse_). We can then run the topic model. For a corpus of 11,000 abstracts, starting with $K=100$ (the number of topics) provides a reasonable basis for exploration.



```{r}
#| echo: TRUE
#| eval: FALSE
#| label: "Pre-processing"

# ----------------------------------
# STEP 1: DATA PREPARATION
# ----------------------------------

# Retain only rows with a gender 
# Retain only rows with an abstract
# Retain only rows after 1980

data <- data %>% 
  filter(!is.na(gender_expanded),
         !is.na(abstract_fr),
         year_defence > 1979
         )

# ----------------------------------
# STEP 2: TOKENIZATION AND PARSING
# ----------------------------------

# Initialize the spaCy model for French
# Ensure spaCy is installed and the French language model is downloaded.
# spacy_install(force = TRUE)
# spacy_download_langmodel("fr_core_news_lg", force = TRUE)

spacy_initialize("fr_core_news_lg") 

# Parse titles using spaCy
# Perform pre-cleaning on French abstracts

parsed <- data %>%
  # some pre-cleaning of abstract
  mutate(abstract_fr = str_to_lower(abstract_fr),
         abstract_fr = str_replace_all(abstract_fr, "", " ") %>% str_replace_all(., "", " "),
         abstract_fr = str_remove_all(abstract_fr, "$\\(?Résumé"),
         abstract_fr = str_replace_all(abstract_fr, "-", " "),
         abstract_fr = str_squish(abstract_fr)) %>% 
  pull(abstract_fr) %>%
  # identify words 
  spacyr::spacy_parse(multithread = TRUE)

# Map thesis IDs to the parsed tokens
id <- data %>% 
  distinct(thesis_id) %>% 
  ungroup %>% 
  mutate(doc_id = paste0("text", 1:n()))

parsed <- parsed %>% 
  left_join(id, join_by(doc_id)) %>% 
  select(-doc_id)

saveRDS(parsed, here(website_data_path, "parsed.rds"), compress = TRUE)

# ----------------------------------
# STEP 3: TOKEN FILTERING AND CLEANING
# ----------------------------------

parsed <- readRDS(here(website_data_path, "parsed.rds"))

# prepare stop_words
stop_words <- bind_rows(
  get_stopwords(language = "fr", source = "stopwords-iso"),
  get_stopwords(language = "fr", source = "snowball"),
  # some titles have english expression
  get_stopwords(language = "en", source = "snowball")) %>%
  distinct(word) %>%
  pull(word)

# add custom stopwords 
custom_stop_words <- c("chapitre", 
                       "thèse",
                       "montrons",
                       "montre",
                       "analyse")

stop_words <- c(stop_words, custom_stop_words)

parsed_filtered <- parsed %>%
  # Count original ids
  mutate(original_count = n_distinct(thesis_id)) %>% 
  
  # Filter empty tokens and track removed ids
  filter(!pos %in% c("PUNCT", "SYM", "SPACE")) %>% 
  mutate(after_filter1 = n_distinct(thesis_id)) %>%
  { message("Doc removed after filter: ", unique(.$original_count) - unique(.$after_filter1)); . } %>% 
  
  # remove special character 
  filter(!token %in% c("-", "δ", "α", "σ", "γ", "東一")) %>% 
  mutate(after_filter2 = n_distinct(thesis_id)) %>%
  { message("Doc removed after filter: ", unique(.$after_filter2) - unique(.$after_filter1)); . } %>%
  
  # remove any digit token (including those with letters after digits such as 12eme)
  filter(!str_detect(token, "^\\d+.*$")) %>%
  mutate(after_filter3 = n_distinct(thesis_id)) %>%
  { message("Doc removed after filter: ", unique(.$after_filter3) - unique(.$after_filter2)); . } %>%
  
  # Remove pronouns and french trunc
  mutate(token = str_remove_all(token, "^[ld]'"),
         token = str_remove_all(token, "[[:punct:]]")) %>%
  # Filter single letters and stopwords
  filter(str_detect(token, "[[:letter:]]{2}")) %>%
  mutate(after_filter4 = n_distinct(thesis_id)) %>%
  { message("Doc removed after filter: ", unique(.$after_filter3) - unique(.$after_filter4)); . } %>%
  
  # filter list of stop words 
  filter(!token %in% stop_words) %>%
  mutate(after_filter5 = n_distinct(thesis_id)) %>%
  { message("Doc removed after filter: ", unique(.$after_filter5) - unique(.$after_filter4)); . } %>%
  
  # Create bigrams
  group_by(thesis_id, sentence_id) %>%
  mutate(bigram = ifelse(token_id < lead(token_id), str_c(token, lead(token), sep = "_"), NA)) %>%
  ungroup()

# ----------------------------------
# STEP 4: BIGRAM CREATION AND FILTERING
# ----------------------------------

# Create and filter bigrams based on frequency and PMI
bigrams <- parsed_filtered %>%
  select(thesis_id, sentence_id, token_id, bigram) %>%
  filter(!is.na(bigram)) %>%
  mutate(window_id = 1:n()) %>%
  add_count(bigram) %>%
  filter(n > 10) %>%
  separate(bigram, c("word_1", "word_2"), sep = "_") %>%
  filter(if_all(starts_with("word"), ~ ! . %in% stop_words))

bigram_pmi_values <- bigrams %>%
  pivot_longer(cols = starts_with("word"), names_to = "rank", values_to = "word") %>%
  mutate(word = paste0(rank, "_", word)) %>%
  select(window_id, word, rank) %>%
  widyr::pairwise_pmi(word, window_id) %>%
  arrange(item1, pmi) %>%
  filter(str_detect(item1, "word_1")) %>%
  mutate(across(starts_with("item"), ~str_remove(., "word_(1|2)_"))) %>%
  rename(word_1 = item1,
         word_2 = item2,
         pmi_bigram = pmi) %>%
  group_by(word_1) %>%
  mutate(rank_pmi_bigram = 1:n())

bigrams_to_keep <- bigrams %>%
  left_join(bigram_pmi_values) %>%
  filter(pmi_bigram > 3) %>%
  mutate(bigram = paste0(word_1, "_", word_2)) %>%
  distinct(bigram) %>%
  mutate(keep_bigram = TRUE)

parsed_final <- parsed_filtered %>%
  left_join(bigrams_to_keep) %>%
  mutate(token = if_else(keep_bigram, bigram, token, missing = token),
         token = if_else(lag(keep_bigram), lag(bigram), token, missing = token),
         token_id = if_else(lag(keep_bigram), token_id - 1, token_id, missing = token_id)) %>%
  distinct(thesis_id, sentence_id, token_id, token)

term_list <- parsed_final %>% 
  rename(term = token)

saveRDS(term_list, here(website_data_path, "term_list.rds"))

# ----------------------------------
# STEP 5: STM INPUT PREPARATION
# ----------------------------------

term_list <- readRDS(here(website_data_path, "term_list.rds"))

# stm object with covariate 
metadata <- term_list %>%
  distinct(thesis_id) %>% 
  left_join(data, by = "thesis_id") %>% 
  mutate(year_defence = as.numeric(year_defence)) %>% 
  distinct(thesis_id, abstract_fr, year_defence, gender_expanded) %>%
  # filter lines with na covariates 
  filter(!is.na(abstract_fr),
         !is.na(gender_expanded), 
         !is.na(year_defence))

# Convert term list to STM-ready format
corpus_in_dfm <- term_list %>%
  # remove observations deleted by the metadata filter 
  filter(thesis_id %in% metadata$thesis_id) %>% 
  add_count(term, thesis_id) %>%
  cast_dfm(thesis_id, term, n)

corpus_in_stm <- quanteda::convert(corpus_in_dfm, to = "stm",  docvars = metadata)

saveRDS(corpus_in_stm, here(website_data_path, "corpus_in_stm.rds"))

# ----------------------------------
# STEP 6: RUNNING THE STM
# ----------------------------------

corpus_in_stm <- readRDS(here(website_data_path, "corpus_in_stm.rds"))

formula_str <- paste("~", "gender_expanded + s(year_defence)")
formula_obj <- as.formula(formula_str)

stm <-
  stm(
    documents = corpus_in_stm$documents,
    vocab = corpus_in_stm$vocab,
    prevalence = formula_obj,
    data = corpus_in_stm$meta,
    K = 100,
    init.type = "Spectral",
    verbose = TRUE,
    seed = 123
  )

saveRDS(stm, here(website_data_path, "stm.rds"))
```

# Analysis 

@fig-theta_summary presents the top 20 topics ranked by average prevalence. For each topic, the most probable words from the topic content (based on the $\beta_{1:K}$ distributions) are assigned. Unsurprisingly, the top topics closely align with common subfields in economics, such as development economics, monetary economics, and the economics of innovation.  

Notably, the topics appear more interpretable than those generated by the other [model](https://tdelcey.github.io/becoming_economists_page/application/stm_title#fig-theta_summary) we ran with `title_fr`. This can be attributed both to the use of a richer source of information and to the fact that we are covering a more recent period, in which topics are more recognizable to contemporary audiences.  

```{r}
#| echo: TRUE 
#| eval: TRUE
#| label: fig-theta_summary
#| fig-cap: "Top 30 topics by prevalence" 

stm <- readRDS(here(website_data_path, "stm.rds"))

label_topic <- labelTopics(stm, n = 7) 

top_terms_prob <- label_topic %>% .[[1]] %>% 
  as_tibble() %>% 
  reframe(topic_label_prob = pmap_chr(., ~ paste(c(...), collapse = ", "))) %>% 
  mutate(topic = row_number()) 

# tidy call gamma the prevalence matrix, stm calls it theta  
theta <- broom::tidy(stm, matrix = "gamma") %>% 
  # broom called stm theta matrix gamma 
  left_join(top_terms_prob, by = "topic") 

#### plot summary of topics ####

theta_mean <- theta %>%
  group_by(topic, topic_label_prob) %>%
  # broom called stm theta matrix gamma 
  summarise(theta = mean(gamma)) %>%
  ungroup %>% 
  mutate(topic = reorder(topic, theta)) %>%  
  slice_max(theta, n = 30)

theta_mean %>%
  ggplot() +
  geom_segment(
    aes(x = 0, xend = theta, y = topic, yend = topic
  ),
  color = "black",
  size = 0.5) +
    geom_text(
    aes(x = theta, y = topic, label = topic_label_prob),
    hjust = -.01,
    size = 3
  ) +
  scale_x_continuous(
    expand = c(0, 0),
    limits = c(0, max(theta_mean$theta)*3.04),
  ) +
  ggthemes::theme_hc() +
  theme(plot.title = element_text(size = 8)) +
  labs(
    x = "Average prevalence by document",
    y = NULL,
    caption =  "Note: words are most probable words"
  )

```

## Effect of gender

Now that we have estimated our topics and ensured their interpretability, we can examine the extent to which the author's gender predicts topic prevalence for a given document. Given the increasing number of female authors over time, topics that are more prevalent in recent theses are more likely to be associated with female authorship. Therefore, we include the `year of defense` in the regression to distinguish between trendy recent topics and topics more commonly chosen by female authors: 

$$ \theta_{d,k} = \beta_0 + \beta_1 * gender_d + \beta_2 * year_d + \epsilon_{d,k} $$

```{r}
#| echo: TRUE
#| eval: FALSE

# create covariates and check level 
corpus_in_stm <- readRDS(here(website_data_path, "corpus_in_stm.rds"))

metadata <- corpus_in_stm$meta %>% 
  as_tibble %>%
  mutate(
    year_defence = as.numeric(year_defence),
    gender_expanded = as.factor(gender_expanded),
    gender_expanded = relevel(gender_expanded, ref = "male")
  )


# check level factor variable
# levels(metadata$gender_expanded)

# create regression formula 

formula_str <- paste("~", "gender_expanded + s(year_defence)")
formula_obj <- as.formula(formula_str)

estimate_effect <- estimateEffect(formula_obj,
                                  stm,
                                  metadata = metadata,
                                  documents = corpus_in_stm$documents,
                                  uncertainty = "Local",
                                  nsims = 25)

saveRDS(estimate_effect, here(website_data_path, "estimate_effect.rds"))
```

@fig-gender_effect presents the significant estimates for the covariate gender_expanded (with a p-value < 0.1). The y-axis represents the topics, while the x-axis shows the effect of being female on the expected topic prevalence. For instance, being a woman increases the probability of topic 35 appearing in a document by 0.077. Given that the average prevalence of topic 35 is around 0.012, this effect accounts for a significant proportion of the topic's overall prevalence.

The first obvious conclusion from this analysis is the presence of a strong gender bias in the choice of thesis topics. Male authors are more likely to work on theoretical topics, particularly in macroeconomics, whereas female authors are more associated with applied topics, especially in the fields of health, labor, and education.


::: panel-tabset
## Plot 

```{r}
#| echo: TRUE 
#| warning: FALSE
#| fig.cap: "Estimate effect of being a female author on topic prevalence"
#| label: fig-gender_effect
#| fig.width: 10
#| fig.height: 10

estimate_effect <-readRDS(here(website_data_path, "estimate_effect.rds"))

summary <- summary(estimate_effect)

summary_tibble <- summary$tables %>% 
  purrr::imap_dfr(~ {
    tibble(
      topic = .y,  # Extract topic number
      term = rownames(.x),  # Covariate names
      estimate = .x[, 1],  # Coefficients
      std_error = .x[, 2],  # Standard errors
      t_value = .x[, 3],  # Confidence interval lower bound 95
      p_value = .x[, 4],   # Confidence interval upper bound 95
    )
  })

gender_estimate <- summary_tibble %>% 
  filter(term == "gender_expandedfemale") 

gg <- gender_estimate %>%
  mutate(tooltip = paste("Estimate:", estimate)) %>%
  left_join(top_terms_prob, by = "topic") %>%
  mutate(
    topic = reorder(topic, estimate),
    effect = ifelse(estimate > 0, "Positive", "Negative"),
    effect = ifelse(p_value >= .1, "Not significant (90%)", effect)
  ) %>% 
  filter(p_value < 0.1) %>%
  ggplot(aes(
    x = topic,
    y = estimate,
    label = paste(topic, "-", topic_label_prob),
    fill = effect,
    text = tooltip
  )) +
  geom_col() +
  geom_text(size = 2.5, position = position_stack(vjust = .5)) +
  scale_fill_manual(
    name = "Effect",
    values = c(
      "Negative" = "#FFFFB3",
      "Positive" = "#8DD3C7",
      "Not significant (90%)" = "lightgrey"
    )
  ) +
  coord_flip() +
  ggthemes::theme_hc() +
  theme(plot.title = element_text(size = 15)) +
  labs(x = NULL, y = "Estimate")


plotly::ggplotly(gg, tooltip = "text") %>%
  plotly::config(displayModeBar = FALSE)


```

## Regression table

```{r}
#| echo: TRUE 
#| warning: FALSE
#| label: tbl-regression
#| tbl.cap: "Régression de la prévalence avec interaction"

summary_tibble %>% 
  DT::datatable(
  extensions = 'Buttons',
  options = list(
    dom = 'Blfrtip',
    buttons = c('excel', 'csv'),
    pageLength = 11
  )
)
```

:::

For a more detailed historical analysis, it is also possible to look for an interaction effect between year and gender in the regression if you are interested in exploring how gender-based topic preferences evolve over time:

$$ \theta_{d,k} = \beta_0 + \beta_1 * gender_d * year_d + \epsilon_{d,k} $$
For instance, certain topics may have been strongly associated with one gender in the early 1980s before becoming neutral or even dominated by the other gender. Here, the estimate give, for each value of `year_defence` the effect of being female on the expected prevalence of a given topic.

@fig-regression_interaction presents the results of such an analysis. For each `year_defense` and `gender_expanded`, we compute the expected topic prevalence of topic 35, 53 and 92. Topics 35 and 53 are examples of topic prevalence associated with women and men, respectively. Topic 92 provides a more interesting insight: while this topic is generally associated with male authors, it was mostly prevalent in women's theses until the mid-1990s.

```{r}
#| echo: TRUE 
#| eval: TRUE
#| warning: FALSE
#| label: fig-regression_interaction
#| fig.cap: "Régression de la prévalence avec interaction"
#| fig-subcap: 
#|   - "Topic 35"
#|   - "Topic 53"
#|   - "Topic 92"
#| layout-ncol: 3


corpus_in_stm <- readRDS(here(website_data_path, "corpus_in_stm.rds"))

metadata <- corpus_in_stm$meta %>%
  as_tibble %>%
  mutate(
    year_defence = as.numeric(year_defence),
    gender_expanded = as.factor(gender_expanded),
    gender_expanded = relevel(gender_expanded, ref = "male")
  )

estimate_effect_35 <- estimateEffect(
  c(35) ~ gender_expanded * s(year_defence),
  stm,
  metadata = metadata,
  uncertainty = "None",
  # nsims = 25
)

data_summary <- tidystm::extract.estimateEffect(
  estimate_effect_35,
  "year_defence",
  stm,
  method = "continuous",
  moderator = "gender_expanded",
  moderator.value = c("female", "male")
) %>%
  # add topic label
  left_join(top_terms_prob, by = "topic")

gg1 <- data_summary %>%
  filter(covariate.value > 1985) %>%
  ggplot(
    aes(
      x = covariate.value,
      y = estimate,
      ymin = ci.lower,
      ymax = ci.upper,
      color =  moderator.value,
      fill = moderator.value
    )
  ) +
  geom_ribbon(alpha = .5, show.legend = FALSE) +
  geom_line() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = paste("Words:", unique(data_summary$topic_label)),
    subtitle = "Intervalle à 95%",
    # Ensure topic_label is unique
    color = "Gender",
    x = "covariate.value",
    y = "Expected topic prevalence"
  ) +
  scale_fill_manual(values = c("male" = "#FFFFB3", "female" = "#8DD3C7")) +
  scale_color_manual(values = c("male" = "#FFFFB3", "female" = "#8DD3C7")) +
  theme_minimal() +
  theme(strip.text = element_text(size = 3))

estimate_effect_53 <- estimateEffect(
  c(53) ~ gender_expanded * s(year_defence),
  stm,
  metadata = metadata,
  uncertainty = "None",
  # nsims = 25
)

data_summary <- tidystm::extract.estimateEffect(
  estimate_effect_53,
  "year_defence",
  stm,
  method = "continuous",
  moderator = "gender_expanded",
  moderator.value = c("female", "male")
) %>%
  # add topic label
  left_join(top_terms_prob, by = "topic")

gg2 <- data_summary %>%
  filter(covariate.value > 1985) %>%
  ggplot(
    aes(
      x = covariate.value,
      y = estimate,
      ymin = ci.lower,
      ymax = ci.upper,
      color = moderator.value,
      fill = moderator.value
    )
  ) +
  geom_ribbon(alpha = .5, show.legend = FALSE) +
  geom_line() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = paste("Words:", unique(data_summary$topic_label)),
    subtitle = "Intervalle à 95%",
    # Ensure topic_label is unique
    color = "Gender",
    x = "covariate.value",
    y = "Expected topic prevalence"
  ) +
  scale_fill_manual(values = c("male" = "#FFFFB3", "female" = "#8DD3C7")) +
  scale_color_manual(values = c("male" = "#FFFFB3", "female" = "#8DD3C7")) +
  theme_minimal() +
  theme(strip.text = element_text(size = 3))


estimate_effect_92 <- estimateEffect(
  c(92) ~ gender_expanded * s(year_defence),
  stm,
  metadata = metadata,
  uncertainty = "None",
  # nsims = 25
)

data_summary <- tidystm::extract.estimateEffect(
  estimate_effect_92,
  "year_defence",
  stm,
  method = "continuous",
  moderator = "gender_expanded",
  moderator.value = c("female", "male")
) %>%
  # add topic label
  left_join(top_terms_prob, by = "topic")

gg3 <- data_summary %>%
  filter(covariate.value > 1985) %>%
  ggplot(
    aes(
      x = covariate.value,
      y = estimate,
      ymin = ci.lower,
      ymax = ci.upper,
      color =  moderator.value,
      fill = moderator.value
    )
  ) +
  geom_ribbon(alpha = .5, show.legend = FALSE) +
  geom_line() +
  geom_hline(yintercept = 0, linetype = "dashed") +
  labs(
    title = paste("Words:", unique(data_summary$topic_label)),
    subtitle = "Intervalle à 95%",
    # Ensure topic_label is unique
    color = "Gender",
    x = "covariate.value",
    y = "Expected topic prevalence"
  ) +
  scale_fill_manual(values = c("male" = "#FFFFB3", "female" = "#8DD3C7")) +
  scale_color_manual(values = c("male" = "#FFFFB3", "female" = "#8DD3C7")) +
  theme_minimal() +
  theme(strip.text = element_text(size = 3))

print(gg1)
print(gg2)
print(gg3)


``` 


```{r}

```

<!-- # blabla  -->

<!-- ```{r} -->
<!-- #| echo: TRUE -->
<!-- #| eval: FALSE  -->

<!-- # prepare color  -->

<!-- color <- gender_estimate %>% -->
<!--   mutate( -->
<!--     topic = reorder(topic, estimate), -->
<!--     color = ifelse(estimate > 0, "#8DD3C7", "#FFFFB3"), -->
<!--     color = ifelse(p_value >= .1, "grey", color) -->
<!--   ) %>%  -->
<!--   select(topic, color) -->

<!-- # load the model  -->
<!-- stm <- readRDS(here(website_data_path, "stm.rds")) -->

<!-- corr <- stm::topicCorr(stm) -->

<!-- # matrix to table -->
<!-- corr_table <- reshape2::melt(corr$cor)  -->


<!-- label_topic <- labelTopics(stm, n = 10) -->

<!-- nodes <- label_topic %>% .[[1]] %>% -->
<!--   as_tibble() %>% -->
<!--   reframe(topic_label_prob = pmap_chr(., ~ paste(c(...), collapse = ", "))) %>% -->
<!--   mutate(topic = as.factor(row_number())) %>%  -->
<!--   left_join(color) %>%  -->
<!--   rename(source_id = topic) -->

<!-- edges <- corr_table %>%  -->
<!--   dplyr::filter(Var1 != Var2) %>%  -->
<!--   rename(source_id = Var1, -->
<!--          target_id = Var2, -->
<!--          weight = value)  -->

<!-- graph <- tidygraph::tbl_graph(nodes = nodes, edges = edges, directed = FALSE) -->

<!-- # if you want to normalize weigth to handle negative value  -->

<!-- # graph_normalize <- graph %>%  -->
<!-- #   activate(edges) %>%  -->
<!-- #   mutate(weight = rescale(weight, to = c(0.01, 1))) -->


<!-- # fa 2 -->
<!-- graph_layout <- vite::complete_forceatlas2(graph, first.iter = 50000, kgrav = 1) -->

<!-- saveRDS(corr_table, here(website_data_path, "corr_table.rds")) -->

<!-- saveRDS(graph_layout, here(website_data_path, "graph_layout.rds")) -->
<!-- ``` -->


<!-- ::: panel-tabset -->
<!-- ### Réseau de corrélation -->

<!-- ```{r} -->
<!-- #| echo: TRUE  -->
<!-- #| label: fig-corr_network -->
<!-- #| fig-cap: "Réseaux des thématiques (spacialisation par Force Atlas 2)" -->
<!-- #| page-layout: full -->

<!-- graph_layout <- readRDS(here(website_data_path, "graph_layout.rds")) -->

<!-- gg <- ggraph(graph_layout,  -->
<!--              "manual",  -->
<!--              x = x,  -->
<!--              y = y) + -->
<!--   geom_edge_arc0(aes( -->
<!--           width = weight),  -->
<!--           alpha = 0.1, strength = 0.2, show.legend = FALSE) + -->
<!--   scale_edge_width_continuous(range = c(0.01,0.2)) + -->
<!--   geom_point(aes(x = x, y = y)) + -->
<!--   geom_label_repel_interactive(aes( -->
<!--     x = x, -->
<!--     y = y, -->
<!--     label = source_id, -->
<!--     tooltip = topic_label_prob, -->
<!--     data_id = source_id, -->
<!--     color = color -->
<!--   ), -->
<!--   size = 4) + -->
<!--   scale_color_identity() +  -->
<!--   scale_size_continuous(range = c(0.5,3)) + -->
<!--   labs(title = "Les noeuds sont les thématiques, les liens sont les coefficients de corrélation.") + -->
<!--   theme_void() -->

<!-- girafe(ggobj = gg, -->
<!--        width_svg  = 16, -->
<!--        height_svg = 9) -->
<!-- ``` -->

<!-- ### Données -->

<!-- ```{r} -->
<!-- #| echo: TRUE -->
<!-- #| tbl-cap: tbl-corr_table -->
<!-- #| label: "Table de corrélation" -->

<!-- corr_table <- readRDS(here(website_data_path, "corr_table.rds")) -->


<!-- corr_table %>%  -->
<!--   DT::datatable( -->
<!--   extensions = 'Buttons', -->
<!--   options = list( -->
<!--     dom = 'Blfrtip', -->
<!--     buttons = c('excel', 'csv'), -->
<!--     pageLength = 5 -->
<!--   ) -->
<!-- ) -->

<!-- ``` -->
<!-- ::: -->


